- 我们经常会需要选择链表或数组来实现功能；我们在考虑算法中更复杂的数据结构时会反复遇到。
  - 所以在实现栈这种简单的功能时，就确认一下基于链表的栈实现和基于数组的栈实现的优缺点，为后续更复杂的应用做铺垫。
- 使用数组最根本的一个缺点是：**需要实现声明数组的大小，比如栈会有确定的容量。**
  - 容量问题，是所有基于数组实现的算法和数据结构必须处理的基本问题。
  - 简单情况：先作弊，让客户端来提供栈的容量，后面再来处理这个问题。
    - **这肯定不行。——一方面**，用户不知道需要多大的栈；二，用户需要维护许多栈，这些栈在不同的时间达到最大容量。
    - 同时这个容量破坏了我们栈Stack的API，怎么来处理这个问题？
- 重置数组大小——动态数组，解决容量问题。
- **什么时候选数组实现、什么时候选链表实现？**
  - 飞机场这种在乎实时性的操作，如push，pop的实时性，就应该选链表。
    - 数据包以很高的流量进来，不能因为某个操作突然变慢了而丢失数据。此时不能使用数组栈。
  - 因为数组栈在容量倍增时，需要花费更多的时间，可能会带来延时；但是数组栈的均摊时间较小，总时间开销小；适合不需要实时性高的操作，适合总时间较小的操作。

```
1. 构造函数不能是虚函数 virtual Stack(); 错的
2. 接口类函数：虚函数，析构函数，建议派生类重写；其它纯虚函数，派生类一定要重写；

3. 没有实现iterator迭代器时的Stack，要手动遍历时，需要获取private的属性，获取Node的内容，这是不安全的；将数据结构里面的数据设置为private是不安全的；要么写一个去获取它的内容的public get接口；大概就是这个意思
	如果有了迭代器，就能在不知道里面的具体实现的情况下去实现遍历这个操作；从而使用for()这样的方式去实现。
4. C++如何实现迭代器功能？

```

#### C++ 迭代器实现

- 新定义一个Iterator类，去实现里面的功能：


---

## 附录一：为什么动态数组连续N次push，其均摊成本为~O(3N)

- 连续N次push，最终数组大小为N；最大深度为$log_2^N$，深度+1，就等于容量倍增；（这个重点理解一下）
  - 所以深度之和，就是操作次数；然后每次，要访问2次数组；
  - 所以$2^0+2^1+...+2^{log_2^N}=(1-q^n)/(1-q)=q^n=2^{log_2^N}=N$
    - 所以N次连续push操作，放移动N次，每次是访问两个数组；大约均摊操作~O(3N)

当你使用动态数组实现栈时，**push** 操作通常需要在数组末尾添加一个新元素。在大多数情况下，**push** 操作是一个常数时间操作，即 O(1)O(1)。然而，在某些情况下，当数组的容量已满时，必须扩展数组的大小，这将导致一些开销。因此，**push** 操作的平均时间（即均摊时间）为 O(3N)O(3N)，这是基于动态数组扩容的机制。

### 动态数组栈的工作原理：

1. **常规的 push 操作** ：当栈的容量未满时，`push` 操作只是将元素插入到数组的末尾，这是一个常数时间操作 O(1)O(1)。
2. **扩容** ：当栈的容量已满时，必须为数组分配一个更大的内存空间。通常，数组容量会加倍，意味着如果当前数组大小为 kk，扩容后新的数组大小为 2k2k。

扩容操作会涉及到将现有元素从旧数组复制到新数组中，这个过程的时间复杂度是 O(k)O(k)，其中 kk 是旧数组的大小。扩容操作发生在栈的容量已满时，因此在这个步骤中，数组的访问时间不是常数时间，而是线性的。

### 计算均摊时间：

为了计算均摊时间，我们考虑多次 `push` 操作中的扩容和不扩容的情况。

* 假设最初栈的大小为 1，每次扩容时将栈大小加倍。
* **第一次扩容** ：栈从大小为 1 扩容到 2，此时复制了 1 个元素，花费了 O(1)O(1) 时间。
* **第二次扩容** ：栈从大小为 2 扩容到 4，此时复制了 2 个元素，花费了 O(2)O(2) 时间。
* **第三次扩容** ：栈从大小为 4 扩容到 8，此时复制了 4 个元素，花费了 O(4)O(4) 时间。
* 以此类推，每次扩容时都需要复制当前栈中的所有元素。

假设我们进行 NN 次 `push` 操作，其中会有多个扩容过程。在最坏情况下，当数组扩容时，栈的大小是 2k2^k（即容量加倍），在第 kk 次扩容时，复制的元素个数是 $2^{k-1}$。

### 总开销分析：

假设总共有 NN 次 `push` 操作，我们需要计算所有 `push` 操作的总开销，其中包括扩容时的复制开销。每次扩容的开销为 O(2k)O(2^k)，那么所有扩容操作的总开销是：

O(1)+O(2)+O(4)+O(8)+…O(1) + O(2) + O(4) + O(8) + \dots
这个序列是一个等比数列，总和为 O(2N)O(2N)，因此整个扩容过程的总开销是 O(N)O(N)。

### 均摊分析：

为了得到均摊时间，我们把总开销 O(2N)O(2N) 分摊到 NN 次 `push` 操作中，得到每次操作的均摊时间为：

O(2N)N=O(2)\frac{O(2N)}{N} = O(2)
因此，动态数组栈的**均摊时间**是 O(1)O(1)，但是因为扩容时需要复制所有元素，所以对于扩容操作后的开销，经过多次 `push` 操作后，均摊的时间可以接近 O(3N)O(3N)，即每次操作的时间平均为 O(3)O(3)。

### 总结：

* 在进行 NN 次 `push` 操作时，每次扩容的总时间复杂度是 O(N)O(N)。
* 因此，均摊到每次 `push` 操作上的时间复杂度大约是 O(3)O(3)，即 O(3N)O(3N)。
